apply plugin: 'com.android.library'

sourceCompatibility = "1.7"
targetCompatibility = "1.7"

android {
	compileSdkVersion gradle.ext.compileSdkVersion
	buildToolsVersion gradle.ext.buildToolsVersion

	defaultConfig {
		minSdkVersion gradle.ext.minSdkVersion
		targetSdkVersion gradle.ext.targetSdkVersion
		versionCode 2
		versionName "DO_NOT_EDIT"

		testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
	}
	buildTypes {
		release {
			testCoverageEnabled false
			//minifyEnabled false
			//proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
			consumerProguardFiles 'proguard-rules.pro'
		}
		debug {
			testCoverageEnabled = true
		}
	}

	testOptions {
		unitTests.returnDefaultValues = true
	}
}

dependencies {
	compile fileTree(dir: 'libs', include: ['*.jar'])
	compile project(':tasklib-core')
	compile gradle.ext.dep_appcompat
	compile gradle.ext.dep_rxjava

	testCompile gradle.ext.dep_junit
	testCompile gradle.ext.dep_googleTruth
	testCompile gradle.ext.dep_mockito
	testCompile gradle.ext.dep_powermock
	testCompile gradle.ext.dep_powermock_junit
	testCompile gradle.ext.dep_powermock_mockito

}

apply plugin: 'maven-publish'

publishing {
	publications {
		aar(MavenPublication) {
			groupId gradle.ext.taskLibGroupId
			artifactId project.getName()
			version = gradle.ext.taskLibVersion
			artifact("${project.buildDir}/outputs/aar/${project.getName()}-release.aar")
			artifact androidJavadocsJar

			pom.withXml {
				def root = asNode()
				def license = root.appendNode('licenses').appendNode('license')
				license.appendNode('name', 'The Apache Software License, Version 2.0')
				license.appendNode('url', 'http://www.apache.org/licenses/LICENSE-2.0.txt')
				license.appendNode('distribution', 'repo')
			}
		}
	}
}

task androidJavadocs(type: Javadoc) {
	source = android.sourceSets.main.java.srcDirs
	classpath += project.files(android.getBootClasspath().join(File.pathSeparator))
}

task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
	classifier = 'javadoc'
	from androidJavadocs.destinationDir
}

task androidSourcesJar(type: Jar) {
	classifier = 'sources'
	from android.sourceSets.main.java.srcDirs
}

artifacts {
	archives androidSourcesJar
	archives androidJavadocsJar
}

apply plugin: 'jacoco'

jacoco {
	toolVersion = gradle.ext.jacoco_version
}

android {
	testOptions {
		unitTests.all {
			jacoco {
				includeNoLocationClasses = true
			}
		}
	}
}

task jacocoTestReport(type: JacocoReport) { //we use "debug" build type for test coverage (can be other)
	group = "reporting"
	description = "Generate unified Jacoco code coverage report"

	reports {
		xml.enabled = true
		html.enabled = true
		csv.enabled = false
		xml.destination = "${buildDir}/reports/jacocoTestReport.xml"
		html.destination = "${buildDir}/reports/jacoco"
		csv.destination = "${buildDir}/reports/jacocoTestReport.csv"
	}

	def fileFilter = [
			'**/*Test*.*',
			'**/AutoValue_*.*',
			'**/*JavascriptBridge.class',
			'**/R.class',
			'**/R$*.class',
			'**/Manifest*.*',
			'android/**/*.*',
			'**/BuildConfig.*',
			'**/*$ViewBinder*.*',
			'**/*$ViewInjector*.*',
			'**/Lambda$*.class',
			'**/Lambda.class',
			'**/*Lambda.class',
			'**/*Lambda*.class',
			'**/*$InjectAdapter.class',
			'**/*$ModuleAdapter.class',
			'**/*$ViewInjector*.class',
			'**/*_MembersInjector.class', //Dagger2 generated code
			'*/*_MembersInjector*.*', //Dagger2 generated code
			'**/*_*Factory*.*', //Dagger2 generated code
			'*/*Component*.*', //Dagger2 generated code
			'**/*Module*.*' //Dagger2 generated code
	]
	def debugTree = fileTree(dir: "${buildDir}/intermediates/classes/{flavor}/debug", excludes: fileFilter) //we use "debug" build type for test coverage (can be other)
	def mainSrc = "${project.projectDir}/src/main/java"

	sourceDirectories = files([mainSrc])
	classDirectories = files([debugTree])
	executionData = fileTree(dir: "$buildDir", includes: [
			"jacoco/testDebugUnitTest.exec", //we use "debug" build type for test coverage (can be other)
			"outputs/code-coverage/connected/*coverage.ec"
	])
}
